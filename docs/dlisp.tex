% Created 2021-10-12 Tue 17:28
% Intended LaTeX compiler: pdflatex
\documentclass[10pt, a4j, twocolumn]{scrartcl}
               \usepackage{amsmath}
               \usepackage{amssymb}
               \usepackage{xunicode}
               \usepackage{fixltx2e}
               \usepackage{zxjatype}
               \usepackage[hiragino-dx]{zxjafont}
               \usepackage{xltxtra}
               \usepackage{graphicx}
               \usepackage{longtable}
               \usepackage{float}
               \usepackage{wrapfig}
               \usepackage{soul}
               \usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{style}
\author{Jin SANO}
\date{\today}
\title{DLisp\\\medskip
\large Difference List Processor \\ \url{https://github.com/sano-jin/dlisp}}
\hypersetup{
 pdfauthor={Jin SANO},
 pdftitle={DLisp},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 27.2 (Org mode 9.4.4)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents

\vspace{1em}

\textbf{\textbf{TODO}} 

\begin{itemize}
\item 提案書
\begin{itemize}
\item 関連研究を載せる
\item 参考文献を書く（org-mode での書き方がよくわからない）
\item 提案手法を説明する図を追加する
\item モチベをもっとクリアにする
\end{itemize}

\item 実装
\begin{itemize}
\item 実装の容易さのために一度 OCaml のリストに変換してから評価しているので，
差分リストのまま扱うようにする
\item 履歴の最適化（の検討）
\end{itemize}
\end{itemize}


\section{概要}
\label{sec:org870d4a1}

共有されたオブジェクトの破壊的操作を試みる際に，
事前にオブジェクト全体を複製するのではなく，
操作の履歴を発行することで，
過去の状態を復元できる手段を残しながら，
最新のオブジェクトを手にいれるコストを最小化する手法を提案する．

この手法が顕著に活かせる例として，
アトムと差分リストのみからなる Lisp 派生言語 DLisp を実装した．
DLisp は append が \(O(1)\) で可能である
（より正確には（リストの長さではなく）append の回数のアッカーマン関数の逆関数だが，
これは多くの場合静的解析で削減可能と考えられる）．


\section{導入}
\label{sec:orgc9aee2e}

\subsection{背景}
\label{sec:orgcf22e67}

\subsubsection{既存の（言語における）手法}
\label{sec:org1c1fe5c}

従来のプログラミング言語におけるデータの持ち方の考え方
\begin{description}
\item[{C/C++ などの古典的な手続き型言語}] 破壊的更新が標準
\begin{itemize}
\item \texttt{const} が明示的に記述されていないと破壊的更新の可能性を否定できない
\item 共有されているオブジェクトでもお構いなしに破壊的更新を行う
\item どうしても「元のオブジェクト」が欲しくなる場合は，ユーザが明示的にその実装を行う必要がある
\begin{itemize}
\item 再帰的にコピーを行う関数を実装するものと思われる
\end{itemize}
\end{itemize}
\item[{Rust などの比較的新しい手続き型言語}] 破壊的更新を行うが，所有権解析により共有されている可能性を排除することもできる
\begin{itemize}
\item そもそもオブジェクトの共有自体が推奨されない
\item 実行効率は良いし安全性も高いが，制限が強すぎて，一部の低レイヤ好きにしか好まれない
\end{itemize}
\item[{Python/JavaScript などの比較的新しいスクリプト言語}] 関数型の思想を言語仕様・ライブラリなどでどんどん取り入れている
\begin{itemize}
\item 基本的に実行効率はお構いなし
\item ガンガン複製する
\end{itemize}
\item[{関数型言語}] immutable が標準
\begin{itemize}
\item append などを行う際は複製を行う必要がある
\item そもそも append などのコストがかかる作業を避けるプログラムを意識的に書く傾向にある
\item データ構造をめちゃめちゃ工夫して「償却時間は」\(O(1)\) のアルゴリズムを発明する傾向にある
\begin{itemize}
\item \url{https://hackage.haskell.org/package/dlist}
\item \url{https://wiki.haskell.org/Difference\_list}
\item \url{https://okmij.org/ftp/Haskell/zseq.pdf}
\item ただし，あくまで「償却時間」であり，毎回それが保証されるわけではない
\item 「工夫」はあまり自明でない
\item 「工夫」のために無駄な中間データ構造を要求する場合が多い
\begin{itemize}
\item 定数倍で性能が悪化
\item メモリの消費（メモリ消費は GC のタイミングを早めるため速度にも影響するはず）
\end{itemize}
\end{itemize}
\end{itemize}
\item[{論理型言語}] 未具現化変数
\begin{itemize}
\item append は一回しかできない
\item 一度のみ具現化可能というのは Rust の所有権解析と少し似ている
\end{itemize}
\item[{LMNtal}] link による強い制約
\begin{itemize}
\item link は2頂点を繋ぐことしかできない
\item hyperlink を用いてデータを共有することもできるが，
共有物を純粋に保つのが面倒で（共有物を純粋に保たないプログラミングが人類に可能だとは思えない），
静的な検査もないため，
めちゃめちゃバグりやすい
\item 結局 ground を使うことになる
\begin{itemize}
\item C などのように再帰を回してオブジェクトを clone するコードを自前で書かなくて良いというメリットはある
\item が，とてもコストが大きい
\item のにめちゃめちゃ頻繁に使われている
\end{itemize}
\end{itemize}
\end{description}


\subsubsection{提案手法のモチベーションと導入}
\label{sec:orgab386f5}

まとめると，既存の言語では，基本的には「後で元のオブジェクトも使うかもしれないとき」は事前にそのオブジェクト全体を複製する
\begin{itemize}
\item 関数型言語，スクリプト系，LMNtal (with ground)，\ldots{}
\end{itemize}


しかし，それにはとてもコストがかかる
\begin{itemize}
\item オブジェクトの大きさに比例したコスト
\end{itemize}


しかも，後で「使うかもしれない」ということは使わない可能性もある

つまり，既存のパラダイムでは
\begin{enumerate}
\item 「事前に莫大なコストを払い」，
\item 「後で古いものを使うときのコストはゼロ」としていた
\end{enumerate}

しかし，基本的には \textbf{\textbf{新しいものを使う可能性が高い}} と考えられるので，
\begin{enumerate}
\item 「事前のコストは最小化」した上で，
\item 後で「古いものを使いたくなったら（多少の）コストを払って戻す」ようにしたい
\end{enumerate}


そこで，
\begin{enumerate}
\item 「後で元のオブジェクトも使うかもしれない」のに，
破壊的更新を行うときは，「破壊的操作の履歴」をコミットすることにする
\begin{itemize}
\item このコミットは単にアドレスとそこに代入した値のペアさえあればよく，
「オブジェクト全体の複製」などよりも遥かに低コストである
\end{itemize}
\item 新しいものを使い続ける場合は上記の履歴のコミット以外のコストは払わない
\begin{itemize}
\item 最新であるかどうかのチェックはビットが立っているかどうかなどで \(O(1)\) で行う
\end{itemize}
\item 古いものに戻したい場合は，「（多少の）コストを払って復元する」
\begin{itemize}
\item 基本的に新しいものを使い続けることの方が多いはずなので，
\textbf{\textbf{古いものを欲しがる人にコストを払わせる}}
\item ただし，このコストはあくまで破壊的更新の回数（append の回数など）であり，
純粋にできる部分は純粋に保っていたらそこまで大きくはならないはず
\end{itemize}
\end{enumerate}


\subsection{先行研究}
\label{sec:org99d6785}

要調査

\subsubsection{可逆プログラミング}
\label{sec:orge2616bb}
\begin{description}
\item[{Janus}] 低レベルでグラフのようなデータ構造を扱うことまで頭が回っていないように見える（要調査）
\end{description}


\subsubsection{Haskell の DList や高階関数を用いた手法}
\label{sec:org884b901}
\begin{itemize}
\item Thunk が大量発生するのでメモリ効率が悪い
\item 正格の場合は head をとるために \(O(n)\) かかる（と思うのだがもっと調べる必要がある）
\item いづれにせよ，破壊的な接続よりも効率的だとは思えない
\item また，これらの手法は決して自明ではない
（グラフへの拡張を考えたときに不利なはず）
\end{itemize}


\subsection{本稿の構成}
\label{sec:org78ad6c8}

In section \ref{sec:proposal} we briefly introduce the implementation


\section{提案手法}
\label{sec:org773aa7b}

\label{sec:proposal}

\subsection{概要}
\label{sec:orgc9bffcc}

破壊的更新の履歴を木構造で管理する．

欲しいオブジェクトに対応する葉と
現時点で最新のオブジェクトに対応する葉の間のパスの
ノードにある操作（逆操作）を実行しながらこれらのノードを逆向きにつなぎ直す．

最古のノードから最新のオブジェクトに対応するノードまでのパスを
Main stream と呼ぶことにする．
Main stream から派生したパス（Main stream から取り残されてしまったブランチ）を
Sub stream と呼ぶことにする．
\begin{itemize}
\item Master stream と Sub stream は区別できる必要がある（タグをつけておく）
\item と思っていたが，その必要はないかも知れない．
統一した方がより綺麗に実装できる．
ただ，区別していた方が理解が容易である気もするのでとりあえずこのままにしておく．
\end{itemize}



オブジェクトが最新かどうかはそれが参照する履歴ノードが Master stream 上にあり，
かつその次の履歴ノードが存在しない（Master stream の最新である）かで確認できる．
\begin{itemize}
\item より効率化するためにオブジェクト自体にフラグを用意しておくことも考えられる．
\end{itemize}


オブジェクトが最新でなかった場合は
\begin{itemize}
\item オブジェクトが参照する履歴ノードが Sub stream 上であった場合は
\begin{enumerate}
\item Sub stream を上へたどっていき，
\item LCA に到達したら Master stream を下へ（次へ）
最新のオブジェクトに紐づいている履歴ノードまで辿っていき，
\item Master stream 上の操作（逆操作）を帰りがけ順に実行しながら，
履歴ノードに登録されている操作を履歴ノードに元々あった操作の逆操作（順操作）で更新して
Sub stream のノードにする
\item Sub stream 上の操作（逆操作）を帰りがけ順に実行しながら，
履歴ノードに登録されている操作を履歴ノードに元々あった操作の逆操作（順操作）で更新して
Master stream のノードにする
\end{enumerate}
\item オブジェクトが参照する履歴ノードが Master stream 上であった場合は
上記の 2 -- 3 を実行する
\end{itemize}


というだけ（これ以上ないくらい非常にシンプル）

ただし，素朴な手法なので要改良である．
\begin{itemize}
\item 特に差分リストの場合はもっと最適化できる
\end{itemize}


\subsection{実装}
\label{sec:org41932ba}

\lstset{language=Caml,label=orge48e872,caption={History node},captionpos=b,numbers=none}
\begin{lstlisting}
type history_node =
  | Main of
      (node ref * node) *
      history_node ref option
  | Sub of
      (node ref * node) *
      history_node ref
(* node は 差分リストのノード．
 * 現在履歴を管理するデータは差分リストのノードだけ
 *)
\end{lstlisting}


\lstset{language=Caml,label=org1cfc72c,caption={Update},captionpos=b,numbers=none}
\begin{lstlisting}
(** Main stream を辿りながら帰りがけに逆実行する．
辿ってきた node は sub stream 化して逆順につなぐ．
*)
let rec traverse_main_stream parent_ref this_ref =
  match !this_ref with
  | Sub _ -> 
      failwith @@ "substream should not be reached from main stream"
  | Main ((addr, value), next_ref_opt) ->
      (match next_ref_opt with
      | None -> ()
      | Some next_ref -> traverse_main_stream this_ref next_ref);
      let old_value = !addr in
      addr := value;
      this_ref := Sub ((addr, old_value), parent_ref)

(** 履歴を辿る．
+ Sub stream を上へ辿って行き，
+ Main stream (LCA) に辿り着いたら（ただし，LCA の操作は実行しない），[traverse_main_stream] を実行し，
+ その後帰りがけ順に sub stream を順実行しながらこれを main stream 化する．
*)
let rec traverse_history next_ref_opt this_ref =
  match !this_ref with
  | Sub ((addr, value), parent_ref) ->
      traverse_history (Some this_ref) parent_ref;
      let old_value = !addr in
      addr := value;
      this_ref := Main ((addr, old_value), next_ref_opt)
  | Main (addr_value, old_next_ref_opt) ->
      (match old_next_ref_opt with
      | None -> ()
      | Some old_next_ref -> traverse_main_stream this_ref old_next_ref);
      this_ref := Main (addr_value, next_ref_opt)

(** 差分リストを評価する前にはこの関数を実行して，
履歴を辿って差分リストを最新の状態にし，履歴を更新する必要がある．
この関数のみ外部に公開しておけば良い．
*)
let update = traverse_history None
\end{lstlisting}


これだけ．

しかも，Main stream と Sub stream の区別がいらないなら，コード行は更にこの半分以下になる．


\section{例題}
\label{sec:org9086482}

\lstset{language=Lisp,label=orgc62c0a3,caption={Append},captionpos=b,numbers=none}
\begin{lstlisting}
;; ++ は append

(let ((x '(1 2 3)))
  (let ((y (++ x '(4 5 6))))
    (let ((z (++ x '(7 8 9))))
      (let ((w (++ y '(10 11 12))))
        (begin
         (print x)
         (print y)
         (print z)
         (print w)
         (print x)
         (print y)
         (print z)
         (print w)
         )
        )
      )
    )
  )
\end{lstlisting}


これの実行結果が

\begin{verbatim}
(1 2 3)
(1 2 3 4 5 6)
(1 2 3 7 8 9)
(1 2 3 4 5 6 10 11 12)
(1 2 3)
(1 2 3 4 5 6)
(1 2 3 7 8 9)
(1 2 3 4 5 6 10 11 12)
(1 2 3 4 5 6 10 11 12)
\end{verbatim}

こうなる
\begin{itemize}
\item print は引数を評価してそれを標準出力に表示して，引数の値を返す built-in 関数
\end{itemize}


\section{課題}
\label{sec:orgb0d91b7}

\subsection{Occur checking}
\label{sec:orged8cc1f}

自分自身を含むオブジェクトを連結してしまうと，循環してしまうため（素朴な手法では）評価が無限ループしてしまう．

\lstset{language=Lisp,label=org3478d66,caption={Circle},captionpos=b,numbers=none}
\begin{lstlisting}
(let ((x '(1 2 3)))
  (let ((y (++ x x)))
    (begin
     (print x)
     (print y)
     )
    )
  )
\end{lstlisting}

これを防ぐためには連結の前に Occur checking，
つまり連結しようとしているオブジェクトに「重なり」がないかをチェックしてやれば良い．

Occur checking の（素朴な）実装は Union-find を用いれば良い．
差分リストの id（オブジェクトのアドレスを用いれば良い）で素集合データ構造を作ってやれば，
アッカーマン関数の逆関数のオーダで自分自身を含む差分リストを連結しようとしてないかが判別できる．
本実装ではそのようになっている．
もちろん理想的には静的に所有権解析などを行うことで，
この動的な手間はほとんどの例で削減が可能と思われる．
\begin{itemize}
\item より理想的には SMT solver などを用いて等式論理を解くものと思われる
\end{itemize}

自分自身を含む差分リストを連結しようとしている場合は，残念ながら従来の append を行う他ないと思われる．
\begin{itemize}
\item が，そもそも自分自身を連結するコードをユーザがそんな頻繁に書くとは思えない．
同じものをたくさん並べることは基本的には無意味なので．
\end{itemize}


\subsection{その他最適化手法}
\label{sec:org20d4bd0}
\begin{itemize}
\item 現実装は，すごく安直で，
全ての操作を逆実行する（Nil（未具現化変数）の更新（具現化）をした部分もわざわざ戻す）が，
差分リストの場合は最適化が可能
\begin{itemize}
\item 現実装は一般のグラフへの適用を考えた（差分リストに最適化されていない）素朴な手法
\end{itemize}
\end{itemize}


\section{まとめ}
\label{sec:org2c07afe}

共有されたオブジェクトの破壊的操作を試みる際に，
事前にオブジェクト全体を複製するのではなく，
操作の履歴を発行することで，
過去の状態を復元できる手段を残しながら，
最新のオブジェクトを手にいれるコストを最小化する手法を提案する．

この手法が顕著に活かせる例として，
アトムと差分リストのみからなる Lisp 派生言語 DLisp を実装した．
DLisp は append が \(O(1)\) で可能である（より正確にはアッカーマン関数の逆関数）．




\section{メモ}
\label{sec:org3a98c9e}

差分リストはリストよりも強力なデータ構造
\begin{itemize}
\item append が \(O(1)\) でできる
\item 他の操作はリストと同等
\end{itemize}


ただし，差分リストの append


\section{2021/10/10}
\label{sec:org7efbc89}

提案手法は，単に共有物に対して破壊的操作を行っている場合は履歴を保持するというだけ．
\begin{itemize}
\item つまり，これはグラフに限らず，例えば配列などに対しても適用可能ではある．
\item ただし，配列はめちゃめちゃ破壊的操作を行うため，
履歴が大量発生する＆戻すのに操作の数だけ逆操作するため，あんまり嬉しくはない．
\item （単方向の）差分リスト（もどき）が嬉しいのは，
「末尾の破壊的更新」しかできないということであった．
\begin{itemize}
\item 末尾の破壊的更新以外は純粋にできるため，それらの履歴の保持が不要であり，
「履歴のコストが比較的小さい」というメリットがあった．
\item これは先週の段階ではぼんやりとしか理解していなかった（ので説明ができなかった）
\item こう言った性質をグラフ（の shapetype のような型）において自動的に導出できるのかは不明．
\item 双方向リストにしてしまうと，Head に cons するだけでも破壊的更新をする必要があり，
この履歴も管理せざるを得なくなるため，履歴のコストが無視できなくなる（かも）
\item 現実装は，すごく安直で，全ての操作を逆実行する（Nil（未具現化変数）の更新（具現化）をした部分もわざわざ戻す）が，
こういった部分に関しても差分リストの場合は最適化が可能
\begin{itemize}
\item 現実装は一般のグラフへの適用を考えた（差分リストに最適化されていない）素朴な手法
\end{itemize}
\item 差分リストの場合は move 可能な部分は履歴を管理する必要がないというのが僕の直感的な理解
（あまりきちんと説明できないのでちゃんと例題を書く必要がある）
\begin{itemize}
\item ただし，一般のデータ構造に対してはこれは保証できないことに気づいた
（配列の破壊的代入など）
\end{itemize}
\end{itemize}
\end{itemize}


まとめると，
\begin{itemize}
\item 提案手法が差分リスト（もどき）において有効なのはほぼ確信している．
\begin{itemize}
\item これをあまり理解してもらえなかったのは純粋に説明が悪かったのだと思う．
\end{itemize}
\item 提案手法がより一般のグラフにおいて最適化可能なのかはよくわからない．
\begin{itemize}
\item 操作の数だけ復元にコストがかかる可能性がある．
\end{itemize}
\item が，仮に最適化できなかったとしても，「純粋（風に）にグラフ（破壊的データ構造）を扱う」という
「今まで人類ができなかったこと（調べ学習が足りていない感はある）」を実現しているのでこれは価値があると思っている．
\begin{itemize}
\item つまり，「今までできていたことをより良くする研究」ではないということ．
\end{itemize}
\item 提案手法が一般にはコストゼロで途中の move と組み合わせられない
（move できる部分は履歴の保持がいらないというのは一般には保証できない）のは痛手であったが，
所有権解析を取り入れている言語は「徹頭徹尾」move させるようにしているので，
途中の move があまり最適でないというのは仕方のないことだと言える．
\begin{itemize}
\item ただし，差分リストの場合はこれがおそらく可能で，
どういうパターンのときにそうなるのかはもっと考える必要がある（考える価値があると思う）
\end{itemize}
\end{itemize}


（木だけではなく）グラフ（特に差分リスト）を扱うメリット：
\begin{itemize}
\item グラフを扱えるとより時間効率の良い実装ができる場合がある．
\begin{itemize}
\item キューなど
\item 末尾再帰化してループへ変換できる関数がある．
\end{itemize}
\item グラフを扱えるとより空間効率の良い実装ができる場合がある．
\begin{itemize}
\item 従来の append は第一引数のリストを複製するため，その分メモリを消費する．
\item 末尾再帰化可能でない関数はスタックを消費する．
\end{itemize}
\item グラフを扱えるとより直感的に記述できる可能性がある．
\begin{itemize}
\item キュー．2本スタックを用意するのはすごく直感的というわけではない．
\end{itemize}
\end{itemize}


そもそも所有権解析により，常に move させるようにするのではダメなのか？
\begin{itemize}
\item 常に move させるのでは困るという明確な例題は正直あまり思い付いていない．
\item だが，例えば python ユーザに所有権解析を押し付けるのはどうかと思う．
\begin{itemize}
\item という非形式的な感想しかないと言われればそこまで．
\end{itemize}
\item alim さんの ground を用いた hypergraph による lambda も ground を用いていて，
しかもラムダ式は木にちょっと毛が生えたくらいだから提案手法で（効率的に）扱えないと困る．
\begin{itemize}
\item この場合，ground のように丸々コピーするよりも遥かに安価である（あって欲しい）
\item しかし，そもそも lambda のエンコードの価値が実はあまりよくわからないから，
これが最適化されることの意味もよくわからない．
\end{itemize}
\end{itemize}
\end{document}
